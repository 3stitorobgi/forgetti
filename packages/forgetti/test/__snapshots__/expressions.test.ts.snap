// Vitest Snapshot v1

exports[`expressions > should optimize JSX Element 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(10), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.title;
  let _eq2 = Object.is(_c[2], _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  let _v4 = _eq ? _c[3] : _c[3] = _v.title;
  let _eq3 = Object.is(_c[4], _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4;
  let _eq4 = _eq2 && _eq3,
    _v6 = _eq4 ? _c[5] : _c[5] = <h1 title={_v3}>Title: {_v5}</h1>;
  let _eq5 = Object.is(_c[6], _v6),
    _v7 = _eq5 ? _c[6] : _c[6] = _v6;
  let _v8 = _eq ? _c[7] : _c[7] = _v.children;
  let _eq6 = Object.is(_c[8], _v8),
    _v9 = _eq6 ? _c[8] : _c[8] = _v8;
  let _eq7 = _eq5 && _eq6,
    _v10 = _eq7 ? _c[9] : _c[9] = <div>
      {_v7}
      {_v9}
    </div>;
  return _v10;
}"
`;

exports[`expressions > should optimize JSX Fragment 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(10), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.title;
  let _eq2 = Object.is(_c[2], _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  let _v4 = _eq ? _c[3] : _c[3] = _v.title;
  let _eq3 = Object.is(_c[4], _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4;
  let _eq4 = _eq2 && _eq3,
    _v6 = _eq4 ? _c[5] : _c[5] = <h1 title={_v3}>Title: {_v5}</h1>;
  let _eq5 = Object.is(_c[6], _v6),
    _v7 = _eq5 ? _c[6] : _c[6] = _v6;
  let _v8 = _eq ? _c[7] : _c[7] = _v.children;
  let _eq6 = Object.is(_c[8], _v8),
    _v9 = _eq6 ? _c[8] : _c[8] = _v8;
  let _eq7 = _eq5 && _eq6,
    _v10 = _eq7 ? _c[9] : _c[9] = <>
      {_v7}
      {_v9}
    </>;
  return _v10;
}"
`;

exports[`expressions > should optimize array expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(8), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.a;
  let _eq2 = Object.is(_c[2], _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  let _v4 = _eq ? _c[3] : _c[3] = _v.b;
  let _eq3 = Object.is(_c[4], _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4;
  let _v6 = _eq ? _c[5] : _c[5] = _v.c;
  let _eq4 = Object.is(_c[6], _v6),
    _v7 = _eq4 ? _c[6] : _c[6] = _v6;
  let _eq5 = _eq2 && _eq3 && _eq4,
    _v8 = _eq5 ? _c[7] : _c[7] = [_v3, _v5, ..._v7];
  return _v8;
}"
`;

exports[`expressions > should optimize assignment expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(5), []);
  let a;
  let b;
  let c;
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.x;
  let _eq2 = Object.is(_c[2], _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  let _v4 = c = _v3;
  let _eq3 = Object.is(_c[3], _v4),
    _v5 = _eq3 ? _c[3] : _c[3] = _v4;
  let _v6 = b = _v5;
  let _eq4 = Object.is(_c[4], _v6),
    _v7 = _eq4 ? _c[4] : _c[4] = _v6;
  let _v8 = a = _v7;
  _v8;
}"
`;

exports[`expressions > should optimize await/yield expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
async function Example(props) {
  let _c = _useMemo(() => new Array(5), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.call;
  let _eq2 = Object.is(_c[2], _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  let _v4 = _eq2 ? _c[3] : _c[3] = _v3();
  let _eq3 = Object.is(_c[4], _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4;
  return await _v5;
}"
`;

exports[`expressions > should optimize binary expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(5), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.a;
  let _eq2 = Object.is(_c[2], _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  let _v4 = _eq ? _c[3] : _c[3] = _v.b;
  let _eq3 = Object.is(_c[4], _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4;
  return _v3 + _v5;
}"
`;

exports[`expressions > should optimize call expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(4), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.call;
  let _eq2 = Object.is(_c[2], _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  let _v4 = _eq2 ? _c[3] : _c[3] = _v3();
  return _v4;
}"
`;

exports[`expressions > should optimize conditional expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c4 = _useMemo(() => new Array(4), []);
  let _eq2 = Object.is(_c4[3], (() => {
      let _c = _c4[2] || (_c4[2] = []);
      let _eq = Object.is(_c[0], props),
        _v2 = _eq ? _c[0] : _c[0] = props;
      let _v3 = _eq ? _c[1] : _c[1] = _v2.a;
      let _v;
      if (_v3) {
        let _c2 = _c4[0] || (_c4[0] = []);
        let _v4 = _eq ? _c2[0] : _c2[0] = _v2.b;
        _v = _v4;
      } else {
        let _c3 = _c4[1] || (_c4[1] = []);
        let _v5 = _eq ? _c3[0] : _c3[0] = _v2.c;
        _v = _v5;
      }
      return _v;
    })()),
    _v6 = _eq2 ? _c4[3] : _c4[3] = (() => {
      let _c = _c4[2] || (_c4[2] = []);
      let _eq = Object.is(_c[0], props),
        _v2 = _eq ? _c[0] : _c[0] = props;
      let _v3 = _eq ? _c[1] : _c[1] = _v2.a;
      let _v;
      if (_v3) {
        let _c2 = _c4[0] || (_c4[0] = []);
        let _v4 = _eq ? _c2[0] : _c2[0] = _v2.b;
        _v = _v4;
      } else {
        let _c3 = _c4[1] || (_c4[1] = []);
        let _v5 = _eq ? _c3[0] : _c3[0] = _v2.c;
        _v = _v5;
      }
      return _v;
    })();
  return _v6;
}"
`;

exports[`expressions > should optimize function expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(2), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = () => {
    console.log(props.message);
  };
  return _v2;
}"
`;

exports[`expressions > should optimize guaranteed literals 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(1), []);
  let _v = _c[0] || (_c[0] = 1 + 2);
  return _v;
}"
`;

exports[`expressions > should optimize identifiers 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(1), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  return _v;
}"
`;

exports[`expressions > should optimize logical expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c3 = _useMemo(() => new Array(3), []);
  let _eq2 = Object.is(_c3[2], (() => {
      let _c = _c3[1] || (_c3[1] = []);
      let _eq = Object.is(_c[0], props),
        _v2 = _eq ? _c[0] : _c[0] = props;
      let _v3 = _eq ? _c[1] : _c[1] = _v2.a;
      let _v;
      if (_v3) {
        let _c2 = _c3[0] || (_c3[0] = []);
        let _v4 = _eq ? _c2[0] : _c2[0] = _v2.b;
        _v = _v4;
      } else _v = _v3;
      return _v;
    })()),
    _v5 = _eq2 ? _c3[2] : _c3[2] = (() => {
      let _c = _c3[1] || (_c3[1] = []);
      let _eq = Object.is(_c[0], props),
        _v2 = _eq ? _c[0] : _c[0] = props;
      let _v3 = _eq ? _c[1] : _c[1] = _v2.a;
      let _v;
      if (_v3) {
        let _c2 = _c3[0] || (_c3[0] = []);
        let _v4 = _eq ? _c2[0] : _c2[0] = _v2.b;
        _v = _v4;
      } else _v = _v3;
      return _v;
    })();
  return _v5;
}"
`;

exports[`expressions > should optimize member expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(2), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.example;
  return _v2;
}"
`;

exports[`expressions > should optimize new expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(2), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = new X(_v);
  return _v2;
}"
`;

exports[`expressions > should optimize object expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(6), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.a;
  let _v3 = _eq ? _c[2] : _c[2] = _v.b;
  let _v4 = _eq ? _c[3] : _c[3] = _v.c;
  let _eq2 = Object.is(_c[4], _v4),
    _v5 = _eq2 ? _c[4] : _c[4] = _v4;
  let _eq3 = _eq && _eq2,
    _v6 = _eq3 ? _c[5] : _c[5] = {
      a: _v2,
      b: _v3,
      ..._v5
    };
  return _v6;
}"
`;

exports[`expressions > should optimize sequence expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(7), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.a;
  let _eq2 = Object.is(_c[2], _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  let _v4 = _eq2 ? _c[3] : _c[3] = _v3();
  let _v5 = _eq ? _c[4] : _c[4] = _v.b;
  let _eq3 = Object.is(_c[5], _v5),
    _v6 = _eq3 ? _c[5] : _c[5] = _v5;
  let _v7 = _eq3 ? _c[6] : _c[6] = _v6();
  return _v4, _v7;
}"
`;

exports[`expressions > should optimize tagged templates 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(12), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.tag;
  let _eq2 = Object.is(_c[2], _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  let _v4 = _eq ? _c[3] : _c[3] = _v.a;
  let _eq3 = Object.is(_c[4], _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4;
  let _v6 = _eq3 ? _c[5] : _c[5] = _v5();
  let _eq4 = Object.is(_c[6], _v6),
    _v7 = _eq4 ? _c[6] : _c[6] = _v6;
  let _v8 = _eq ? _c[7] : _c[7] = _v.b;
  let _eq5 = Object.is(_c[8], _v8),
    _v9 = _eq5 ? _c[8] : _c[8] = _v8;
  let _v10 = _eq5 ? _c[9] : _c[9] = _v9();
  let _eq6 = Object.is(_c[10], _v10),
    _v11 = _eq6 ? _c[10] : _c[10] = _v10;
  let _eq7 = _eq2 && _eq4 && _eq6,
    _v12 = _eq7 ? _c[11] : _c[11] = _v3\`\${_v7}, \${_v11}\`;
  return _v12;
}"
`;

exports[`expressions > should optimize template literals 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(10), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.a;
  let _eq2 = Object.is(_c[2], _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  let _v4 = _eq2 ? _c[3] : _c[3] = _v3();
  let _eq3 = Object.is(_c[4], _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4;
  let _v6 = _eq ? _c[5] : _c[5] = _v.b;
  let _eq4 = Object.is(_c[6], _v6),
    _v7 = _eq4 ? _c[6] : _c[6] = _v6;
  let _v8 = _eq4 ? _c[7] : _c[7] = _v7();
  let _eq5 = Object.is(_c[8], _v8),
    _v9 = _eq5 ? _c[8] : _c[8] = _v8;
  let _eq6 = _eq3 && _eq5,
    _v10 = _eq6 ? _c[9] : _c[9] = \`\${_v5}, \${_v9}\`;
  return _v10;
}"
`;

exports[`expressions > should optimize unary expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
function Example(props) {
  let _c = _useMemo(() => new Array(3), []);
  let _eq = Object.is(_c[0], props),
    _v = _eq ? _c[0] : _c[0] = props;
  let _v2 = _eq ? _c[1] : _c[1] = _v.a;
  let _eq2 = Object.is(_c[2], _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  return !_v3;
}"
`;
